{"ast":null,"code":"import { Observable, merge, from, of } from 'rxjs';\nimport { delay, map, switchMap, scan, distinctUntilChanged, withLatestFrom, skipWhile } from 'rxjs/operators';\nimport { onChildAdded, onChildRemoved, onChildChanged, onChildMoved, onValue, off, get as get$1 } from 'firebase/database';\nimport { __assign, __spreadArray } from 'tslib';\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _a;\n\nvar ListenEvent = /*#__PURE__*/(() => {\n  (function (ListenEvent) {\n    ListenEvent[\"added\"] = \"child_added\";\n    ListenEvent[\"removed\"] = \"child_removed\";\n    ListenEvent[\"changed\"] = \"child_changed\";\n    ListenEvent[\"moved\"] = \"child_moved\";\n    ListenEvent[\"value\"] = \"value\";\n  })(ListenEvent || (ListenEvent = {}));\n\n  return ListenEvent;\n})();\nvar ListenerMethods = Object.freeze((_a = {}, _a[ListenEvent.added] = onChildAdded, _a[ListenEvent.removed] = onChildRemoved, _a[ListenEvent.changed] = onChildChanged, _a[ListenEvent.moved] = onChildMoved, _a[ListenEvent.value] = onValue, _a));\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Create an observable from a Database Reference or Database Query.\n * @param ref Database Reference\n * @param event Listen event type ('value', 'added', 'changed', 'removed', 'moved')\n */\n\nfunction fromRef(ref, event) {\n  return new Observable(function (subscriber) {\n    var fn = ListenerMethods[event](ref, function (snapshot, prevKey) {\n      subscriber.next({\n        snapshot: snapshot,\n        prevKey: prevKey,\n        event: event\n      });\n    }, subscriber.error.bind(subscriber));\n    return {\n      unsubscribe: function () {\n        off(ref, event, fn);\n      }\n    };\n  }).pipe( // Ensures subscribe on observable is async. This handles\n  // a quirk in the SDK where on/once callbacks can happen\n  // synchronously.\n  delay(0));\n}\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Check the length of the provided array. If it is empty return an array\n * that is populated with all the Realtime Database child events.\n * @param events\n */\n\n\nfunction validateEventsArray(events) {\n  if (events == null || events.length === 0) {\n    events = [ListenEvent.added, ListenEvent.removed, ListenEvent.changed, ListenEvent.moved];\n  }\n\n  return events;\n}\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Get the snapshot changes of an object\n * @param query\n */\n\n\nfunction object(query) {\n  return fromRef(query, ListenEvent.value);\n}\n/**\n * Get an array of object values, optionally with a mapped key\n * @param query object ref or query\n * @param keyField map the object key to a specific field\n */\n\n\nfunction objectVal(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return fromRef(query, ListenEvent.value).pipe(map(function (change) {\n    return changeToData(change, options);\n  }));\n}\n\nfunction changeToData(change, options) {\n  var _a;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var val = change.snapshot.val(); // match the behavior of the JS SDK when the snapshot doesn't exist\n\n  if (!change.snapshot.exists()) {\n    return val;\n  } // val can be a primitive type\n\n\n  if (typeof val !== 'object') {\n    return val;\n  }\n\n  return __assign(__assign({}, val), options.keyField ? (_a = {}, _a[options.keyField] = change.snapshot.key, _a) : null);\n}\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nfunction stateChanges(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var events = validateEventsArray(options.events);\n  var childEvent$ = events.map(function (event) {\n    return fromRef(query, event);\n  });\n  return merge.apply(void 0, childEvent$);\n}\n\nfunction get(query) {\n  return from(get$1(query)).pipe(map(function (snapshot) {\n    var event = ListenEvent.value;\n    return {\n      snapshot: snapshot,\n      prevKey: null,\n      event: event\n    };\n  }));\n}\n\nfunction list(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var events = validateEventsArray(options.events);\n  return get(query).pipe(switchMap(function (change) {\n    if (!change.snapshot.exists()) {\n      return of([]);\n    }\n\n    var childEvent$ = [of(change)];\n    events.forEach(function (event) {\n      childEvent$.push(fromRef(query, event));\n    });\n    return merge.apply(void 0, childEvent$).pipe(scan(buildView, []));\n  }), distinctUntilChanged());\n}\n/**\n * Get an object mapped to its value, and optionally its key\n * @param query object ref or query\n * @param keyField map the object key to a specific field\n */\n\n\nfunction listVal(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return list(query).pipe(map(function (arr) {\n    return arr.map(function (change) {\n      return changeToData(change, options);\n    });\n  }));\n}\n\nfunction positionFor(changes, key) {\n  var len = changes.length;\n\n  for (var i = 0; i < len; i++) {\n    if (changes[i].snapshot.key === key) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction positionAfter(changes, prevKey) {\n  if (prevKey == null) {\n    return 0;\n  } else {\n    var i = positionFor(changes, prevKey);\n\n    if (i === -1) {\n      return changes.length;\n    } else {\n      return i + 1;\n    }\n  }\n}\n\nfunction buildView(current, change) {\n  var snapshot = change.snapshot,\n      prevKey = change.prevKey,\n      event = change.event;\n  var key = snapshot.key;\n  var currentKeyPosition = positionFor(current, key);\n  var afterPreviousKeyPosition = positionAfter(current, prevKey || undefined);\n\n  switch (event) {\n    case ListenEvent.value:\n      if (change.snapshot && change.snapshot.exists()) {\n        var prevKey_1 = null;\n        change.snapshot.forEach(function (snapshot) {\n          var action = {\n            snapshot: snapshot,\n            event: ListenEvent.value,\n            prevKey: prevKey_1\n          };\n          prevKey_1 = snapshot.key;\n          current = __spreadArray(__spreadArray([], current), [action]);\n          return false;\n        });\n      }\n\n      return current;\n\n    case ListenEvent.added:\n      if (currentKeyPosition > -1) {\n        // check that the previouskey is what we expect, else reorder\n        var previous = current[currentKeyPosition - 1];\n\n        if ((previous && previous.snapshot.key || null) !== prevKey) {\n          current = current.filter(function (x) {\n            return x.snapshot.key !== snapshot.key;\n          });\n          current.splice(afterPreviousKeyPosition, 0, change);\n        }\n      } else if (prevKey == null) {\n        return __spreadArray([change], current);\n      } else {\n        current = current.slice();\n        current.splice(afterPreviousKeyPosition, 0, change);\n      }\n\n      return current;\n\n    case ListenEvent.removed:\n      return current.filter(function (x) {\n        return x.snapshot.key !== snapshot.key;\n      });\n\n    case ListenEvent.changed:\n      return current.map(function (x) {\n        return x.snapshot.key === key ? change : x;\n      });\n\n    case ListenEvent.moved:\n      if (currentKeyPosition > -1) {\n        var data = current.splice(currentKeyPosition, 1)[0];\n        current = current.slice();\n        current.splice(afterPreviousKeyPosition, 0, data);\n        return current;\n      }\n\n      return current;\n    // default will also remove null results\n\n    default:\n      return current;\n  }\n}\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nfunction auditTrail(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var auditTrail$ = stateChanges(query, options).pipe(scan(function (current, changes) {\n    return __spreadArray(__spreadArray([], current), [changes]);\n  }, []));\n  return waitForLoaded(query, auditTrail$);\n}\n\nfunction loadedData(query) {\n  // Create an observable of loaded values to retrieve the\n  // known dataset. This will allow us to know what key to\n  // emit the \"whole\" array at when listening for child events.\n  return fromRef(query, ListenEvent.value).pipe(map(function (data) {\n    // Store the last key in the data set\n    var lastKeyToLoad; // Loop through loaded dataset to find the last key\n\n    data.snapshot.forEach(function (child) {\n      lastKeyToLoad = child.key;\n      return false;\n    }); // return data set and the current last key loaded\n\n    return {\n      data: data,\n      lastKeyToLoad: lastKeyToLoad\n    };\n  }));\n}\n\nfunction waitForLoaded(query, snap$) {\n  var loaded$ = loadedData(query);\n  return loaded$.pipe(withLatestFrom(snap$), // Get the latest values from the \"loaded\" and \"child\" datasets\n  // We can use both datasets to form an array of the latest values.\n  map(function (_a) {\n    var loaded = _a[0],\n        changes = _a[1]; // Store the last key in the data set\n\n    var lastKeyToLoad = loaded.lastKeyToLoad; // Store all child keys loaded at this point\n\n    var loadedKeys = changes.map(function (change) {\n      return change.snapshot.key;\n    });\n    return {\n      changes: changes,\n      lastKeyToLoad: lastKeyToLoad,\n      loadedKeys: loadedKeys\n    };\n  }), // This is the magical part, only emit when the last load key\n  // in the dataset has been loaded by a child event. At this point\n  // we can assume the dataset is \"whole\".\n  skipWhile(function (meta) {\n    return meta.loadedKeys.indexOf(meta.lastKeyToLoad) === -1;\n  }), // Pluck off the meta data because the user only cares\n  // to iterate through the snapshots\n  map(function (meta) {\n    return meta.changes;\n  }));\n}\n\nexport { ListenEvent, ListenerMethods, auditTrail, changeToData, fromRef, list, listVal, object, objectVal, stateChanges }; //# sourceMappingURL=index.esm.js.map","map":null,"metadata":{},"sourceType":"module"}